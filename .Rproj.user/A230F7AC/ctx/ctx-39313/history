}
cl <- makeCluster(5)
clusterExport(cl, ls())
out <- parLapply(cl, 1:rep.runs, function(x){run.onceBnb(p =p, n =n, distro = distro, h = 1,
funcType = funcType, basis = basis,
m.list = m.list)})
rep.runs <- 5
cl <- makeCluster(5)
clusterExport(cl, ls())
out <- parLapply(cl, 1:rep.runs, function(x){run.onceBnb(p =p, n =n, distro = distro, h = 1,
funcType = funcType, basis = basis,
m.list = m.list)})
rep.runs
p <- 6
n <- param.grid[runInd, 1]
distro <- param.grid[runInd, 2]
funcType <- param.grid[runInd, 3]
basis <- param.grid[runInd, 4]
if(basis == "bspline"){
m.list <- c(5, 10, 15, 25, 30)
} else {
m.list <- c(3, 5, 7, 8)
}
cl <- makeCluster(5)
clusterExport(cl, ls())
out <- parLapply(cl, 1:rep.runs, function(x){run.onceBnb(p =p, n =n, distro = distro, h = 1,
funcType = funcType, basis = basis,
m.list = m.list)})
out
tab <- do.call("rbind", out)
outTab <- data.frame(p, n, distro, basis, funcType, tab)
outTab
sample.size <- 200
rep.runs <- 20
n.list <- c(1000, 2000)
d.list <- c("gamma", "gauss", "laplace")
func.list <- c("cam", "tanh", "tanh1")
basis.list <- c("poly", "bspline")
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list, func.list, basis.list)
param.grid
sample.size <- 200
rep.runs <- 20
n.list <- c(1000, 2000)
d.list <- c("gamma", "gauss", "laplace")
func.list <- c("cam", "tanh", "tanh1")
basis.list <- c("poly", "bspline")
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list, func.list, basis.list)
param.grid
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(1/4, 3/4)
p.list <- c(6, 8, 10)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list, func.list, basis.list,
prob.list, p.list)
param.grid
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, p.list)
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(1/4, 3/4)
p.list <- c(6, 8, 10)
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, p.list)
param.grid
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(1/2)
p.list <- c(6, 8, 10)
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, p.list)
sample.size
param.grid
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, n.list)
param.grid
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(3/4)
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, n.list)
param.grid
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(3/4)
p.list <- c(7, 8, 9)
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, n.list)
distro <- param.grid[runInd, 1]
param.grid
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(1/4, 3/4)
p.list <- c(7, 8, 9)
param.grid <- expand.grid(rep(d.list, sample.size / rep.runs), func.list, basis.list,
prob.list, n.list)
param.grid
param.grid
run.onceBnb <- function(p.list = c(7), n, distro, bs = 400, parent_prob = 1/4, K = 10,
funcType = "GP", h = 1, Mtrue= 10, m.list =c(1,2,3),
basis = "bspline") {
totalRec <- matrix(0, 0, 7)
for(pInd in 1:length(p.list)){
p <- p.list[pInd]
rec <- matrix(0, length(m.list) * 3, 7)
colnames(rec) <- c("p"," m", "testFunc", "size", "cover", "ancest", "time")
out <- cdcs::rDAG_anm2(p = p, n = n, parent_prob = parent_prob,
funcType = funcType, M = Mtrue, h = h, dist = distro,
lowScale = 1/5, highScale = sqrt(2)/5, noParentMult = 5)
Y <- out$Y
G1 <- array(0, dim = c(n, K * 2, p) )
G2 <- array(0, dim = c(n, 3, p) )
for(u in 1:p){
for(k in 1:K){
omega <- rnorm(1)
G1[, 2 * k - 1, u] <- scale(sin(omega * Y[,u]))
G1[, 2 * k, u] <- scale(cos(Y[,u] * omega))
}
G2[, 1, u] <- scale(Y[, u]^2)
G2[, 2 , u] <- scale(Y[, u]^3)
G2[, 3 , u] <- scale(sign(Y[,u])*abs(Y[, u])^(2.5))
}
G3 <- abind::abind(G1, G2, along = 2)
for(j in 1:length(m.list)){
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G1, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 1, ] <- c(p, m.list[j], "G1", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G2, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 2, ] <- c(p, m.list[j], "G2", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G3, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 3, ] <- c(p, m.list[j], "G3", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
}
totalRec <- rbind(totalRec, rec)
}
return(rec)
}
run.onceBnb <- function(p.list = c(7), n, distro, bs = 400, parent_prob = 1/4, K = 10,
funcType = "GP", h = 1, Mtrue= 10, m.list =c(1,2,3),
basis = "bspline") {
totalRec <- matrix(0, 0, 7)
for(pInd in 1:length(p.list)){
p <- p.list[pInd]
rec <- matrix(0, length(m.list) * 3, 7)
colnames(rec) <- c("p"," m", "testFunc", "size", "cover", "ancest", "time")
out <- cdcs::rDAG_anm2(p = p, n = n, parent_prob = parent_prob,
funcType = funcType, M = Mtrue, h = h, dist = distro,
lowScale = 1/5, highScale = sqrt(2)/5, noParentMult = 5)
Y <- out$Y
G1 <- array(0, dim = c(n, K * 2, p) )
G2 <- array(0, dim = c(n, 3, p) )
for(u in 1:p){
for(k in 1:K){
omega <- rnorm(1)
G1[, 2 * k - 1, u] <- scale(sin(omega * Y[,u]))
G1[, 2 * k, u] <- scale(cos(Y[,u] * omega))
}
G2[, 1, u] <- scale(Y[, u]^2)
G2[, 2 , u] <- scale(Y[, u]^3)
G2[, 3 , u] <- scale(sign(Y[,u])*abs(Y[, u])^(2.5))
}
G3 <- abind::abind(G1, G2, along = 2)
for(j in 1:length(m.list)){
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G1, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 1, ] <- c(p, m.list[j], "G1", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G2, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 2, ] <- c(p, m.list[j], "G2", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G3, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 3, ] <- c(p, m.list[j], "G3", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
}
totalRec <- rbind(totalRec, rec)
}
return(rec)
}
out <- run.onceBnb(p.list = c(4, 5), n = 5000, distro = "gamma",
h = 1, parent_prob = 3/4,
funcType = "cam", basis = "bspline",
m.list = c(20, 40))
out
run.onceBnb <- function(p.list = c(7), n, distro, bs = 400, parent_prob = 1/4, K = 10,
funcType = "GP", h = 1, Mtrue= 10, m.list =c(1,2,3),
basis = "bspline") {
totalRec <- matrix(0, 0, 7)
for(pInd in 1:length(p.list)){
p <- p.list[pInd]
rec <- matrix(0, length(m.list) * 3, 7)
colnames(rec) <- c("p"," m", "testFunc", "size", "cover", "ancest", "time")
out <- cdcs::rDAG_anm2(p = p, n = n, parent_prob = parent_prob,
funcType = funcType, M = Mtrue, h = h, dist = distro,
lowScale = 1/5, highScale = sqrt(2)/5, noParentMult = 5)
Y <- out$Y
G1 <- array(0, dim = c(n, K * 2, p) )
G2 <- array(0, dim = c(n, 3, p) )
for(u in 1:p){
for(k in 1:K){
omega <- rnorm(1)
G1[, 2 * k - 1, u] <- scale(sin(omega * Y[,u]))
G1[, 2 * k, u] <- scale(cos(Y[,u] * omega))
}
G2[, 1, u] <- scale(Y[, u]^2)
G2[, 2 , u] <- scale(Y[, u]^3)
G2[, 3 , u] <- scale(sign(Y[,u])*abs(Y[, u])^(2.5))
}
G3 <- abind::abind(G1, G2, along = 2)
for(j in 1:length(m.list)){
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G1, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 1, ] <- c(p, m.list[j], "G1", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G2, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 2, ] <- c(p, m.list[j], "G2", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G3, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 3, ] <- c(p, m.list[j], "G3", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
}
totalRec <- rbind(totalRec, rec)
}
return(rec)
}
out <- run.onceBnb(p.list = c(4, 5), n = 5000, distro = "gamma",
h = 1, parent_prob = 3/4,
funcType = "cam", basis = "bspline",
m.list = c(20, 40))
out
n
sample.size <- 200
rep.runs <- 50
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam", "tanh")
basis.list <- c("bspline")
prob.list <- c(1/4, 3/4)
p.list <- c(5, 6, 7)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list, func.list, basis.list,
prob.list, p.list)
runInd <- 1
outTab <- data.frame(read.csv(paste("~/Dropbox/confSetGraphs/code/rPkg/simResults/nl/nl_exp_",runInd, ".csv", sep = ""))[,-1])
n
p.list <- c(4,5)
n <- 1000
distro <- "gamma"
bs <- 400
parent_prob <- 3/4
K <- 10
funcType <- "cam"
Mtrue <- 10
m.list <- c(20, 40)
basis <- "bspline"
totalRec <- matrix(0, 0, 7)
for(pInd in 1:length(p.list)){
p <- p.list[pInd]
print(p)
rec <- matrix(0, length(m.list) * 3, 7)
colnames(rec) <- c("p"," m", "testFunc", "size", "cover", "ancest", "time")
out <- cdcs::rDAG_anm2(p = p, n = n, parent_prob = parent_prob,
funcType = funcType, M = Mtrue, h = h, dist = distro,
lowScale = 1/5, highScale = sqrt(2)/5, noParentMult = 5)
Y <- out$Y
G1 <- array(0, dim = c(n, K * 2, p) )
G2 <- array(0, dim = c(n, 3, p) )
for(u in 1:p){
for(k in 1:K){
omega <- rnorm(1)
G1[, 2 * k - 1, u] <- scale(sin(omega * Y[,u]))
G1[, 2 * k, u] <- scale(cos(Y[,u] * omega))
}
G2[, 1, u] <- scale(Y[, u]^2)
G2[, 2 , u] <- scale(Y[, u]^3)
G2[, 3 , u] <- scale(sign(Y[,u])*abs(Y[, u])^(2.5))
}
G3 <- abind::abind(G1, G2, along = 2)
for(j in 1:length(m.list)){
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G1, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 1, ] <- c(p, m.list[j], "G1", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G2, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 2, ] <- c(p, m.list[j], "G2", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G3, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 3, ] <- c(p, m.list[j], "G3", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
}
totalRec <- rbind(totalRec, rec)
}
rec
pInd <- 1
p <- p.list[pInd]
p
totalRec <- matrix(0, 0, 7)
p <- p.list[pInd]
print(p)
rec <- matrix(0, length(m.list) * 3, 7)
colnames(rec) <- c("p"," m", "testFunc", "size", "cover", "ancest", "time")
out <- cdcs::rDAG_anm2(p = p, n = n, parent_prob = parent_prob,
funcType = funcType, M = Mtrue, h = h, dist = distro,
lowScale = 1/5, highScale = sqrt(2)/5, noParentMult = 5)
Y <- out$Y
G1 <- array(0, dim = c(n, K * 2, p) )
G2 <- array(0, dim = c(n, 3, p) )
for(u in 1:p){
for(k in 1:K){
omega <- rnorm(1)
G1[, 2 * k - 1, u] <- scale(sin(omega * Y[,u]))
G1[, 2 * k, u] <- scale(cos(Y[,u] * omega))
}
G2[, 1, u] <- scale(Y[, u]^2)
G2[, 2 , u] <- scale(Y[, u]^3)
G2[, 3 , u] <- scale(sign(Y[,u])*abs(Y[, u])^(2.5))
}
G3 <- abind::abind(G1, G2, along = 2)
for(j in 1:length(m.list)){
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G1, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 1, ] <- c(p, m.list[j], "G1", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G2, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 2, ] <- c(p, m.list[j], "G2", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G3, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 3, ] <- c(p, m.list[j], "G3", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
}
totalRec <- rbind(totalRec, rec)
pInd <- 2
totalRec
run.onceBnb <- function(p.list = c(7), n, distro, bs = 400, parent_prob = 1/4, K = 10,
funcType = "GP", h = 1, Mtrue= 10, m.list =c(1,2,3),
basis = "bspline") {
totalRec <- matrix(0, 0, 7)
for(pInd in 1:length(p.list)){
p <- p.list[pInd]
rec <- matrix(0, length(m.list) * 3, 7)
colnames(rec) <- c("p"," m", "testFunc", "size", "cover", "ancest", "time")
out <- cdcs::rDAG_anm2(p = p, n = n, parent_prob = parent_prob,
funcType = funcType, M = Mtrue, h = h, dist = distro,
lowScale = 1/5, highScale = sqrt(2)/5, noParentMult = 5)
Y <- out$Y
G1 <- array(0, dim = c(n, K * 2, p) )
G2 <- array(0, dim = c(n, 3, p) )
for(u in 1:p){
for(k in 1:K){
omega <- rnorm(1)
G1[, 2 * k - 1, u] <- scale(sin(omega * Y[,u]))
G1[, 2 * k, u] <- scale(cos(Y[,u] * omega))
}
G2[, 1, u] <- scale(Y[, u]^2)
G2[, 2 , u] <- scale(Y[, u]^3)
G2[, 3 , u] <- scale(sign(Y[,u])*abs(Y[, u])^(2.5))
}
G3 <- abind::abind(G1, G2, along = 2)
for(j in 1:length(m.list)){
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G1, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 1, ] <- c(p, m.list[j], "G1", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G2, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 2, ] <- c(p, m.list[j], "G2", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
time.rec <- system.time(out <- cdcs::brandAndBound_anm(Y, G3, bs =bs, withinAgg = 2,
aggType = 2, alpha = .1, pValueAgg = "tippet",
intercept = 1, verbose = F, basis = basis,
M = m.list[j]))[3]
rec[(j-1) * 3 + 3, ] <- c(p, m.list[j], "G3", sum(out$pValue > .1), all(out[1, -1] == 1:p),
mean(cdcs::getAncest(out[which(out$pValue > .1),-1])[lower.tri(matrix(0, p,p))] == 1 ),
time.rec)
}
totalRec <- rbind(totalRec, rec)
}
return(totalRec)
}
out <- run.onceBnb(p.list = c(4, 5), n = 5000, distro = "gamma",
h = 1, parent_prob = 3/4,
funcType = "cam", basis = "bspline",
m.list = c(20, 40))
out
4 * 3 * 2
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(3/4)
p.list <- c(7, 8, 9)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list, func.list, basis.list,
prob.list)
param.grid
sample.size <- 200
# rep.runs <- 25
rep.runs <- 5
n.list <- c(2500, 5000, 7500, 10000)
d.list <- c("gamma", "laplace")
func.list <- c("cam")
basis.list <- c("bspline")
prob.list <- c(3/4)
p.list <- c(7, 8, 9)
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list, func.list, basis.list,
prob.list)
param.grid
sample.size <- 500
rep.runs <- 10
n.list <- c(500, 1000, 2500, 5000)
d.list <- c("unif", "lognorm", "gamma", "weibull", "laplace", "mixed")
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list)
### Param grid Size 480
param.grid
sample.size <- 500
rep.runs <- 25
n.list <- c(500, 1000, 2500, 5000)
d.list <- c("unif", "lognorm", "gamma", "weibull", "laplace", "mixed")
param.grid <- expand.grid(rep(n.list, sample.size / rep.runs), d.list)
param.grid
